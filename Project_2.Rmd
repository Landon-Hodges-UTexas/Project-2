---
title: "Project 2"
author: "Landon Hodges"
date: "2024-10-26"
output:
  html_document:
      #code_folding: hide
      toc : TRUE
      toc_float: TRUE
      theme: journal
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(tidyverse)
library(ggridges)
library(rvest)
library(kableExtra)
library(GGally)
```

## Introduction

#### Intro to D&D

**Dungeons and Dragons** is a fantasy table-top role playing game. Players make choices to depict characters in a story, and the Game Master describes the world and the consequences of the players' actions. Part of describing that world is bringing to life the horrible **monsters** that inhabit it. These monsters are represented by about 30 statistics that make each monster unique and meaningfully different to fight. These statistics are intended to make combat with the monsters feel responsive to their strengths and weaknesses. This report will use data scraped from [this website](https://www.aidedd.org/dnd-filters/monsters.php), which has compiled by hand all of the officially released "statblocks" from the books published by Wizards of the Coast, the creators of Dungeons and Dragons.

#### Why D&D?

I chose this topic because I love this game and I wanted to highlight its **mechanical** approach to storytelling. It's very interesting how the designers choose to bring to life monsters as different as an Ancient Gold Dragon and and Awakened Tree using the same statistics.

![A Death Dog from the source website](https://www.aidedd.org/dnd/images/death-dog.jpg)

```{r scrumptious scrape}
#Reading and splitting the table by lines
front_page <- read_file('front_page.txt')
split_front_page <- str_split(front_page, '\n')
split_front_page[[1]][1] <- "\tAarakocra\t1/4\tHumanoid (Aarakocra)\tMedium\t12\t13\tfly\tneutral good\t"

#splitting again by tabs
double_split_front_page <- str_split(split_front_page[[1]], '\t')

#sucking out the names and correcting one
names <- c()
for(i in 1:934){
names[i] <- double_split_front_page[[i]][2]
}
names[2] <- 'Aberrant Spirit'

#slapping the names on a standard url
lower_names <- str_to_lower(names)
url_names <- str_replace_all(lower_names, ' ', '-')
urls <- c()
for(i in 1:934){
urls[i] <- str_c('https://www.aidedd.org/dnd/monstres.php?vo=', url_names[i])
}
id_dictionary <- tibble(name=names, id = url_names, )

#Scraping monster data from every page
#TAKES A LONG TIME TO RUN

#monster_data_new <- c()
#for(i in 1:934){
#page <- read_html(urls[i])
#monster_data_new <- append(monster_data_new, html_text(html_elements(page,".source , .red , .type , h1")))
#}

#Saving data for later
#writeLines(monster_data_new, 'monster_data_new.txt')
monster_data_new <- read_lines("monster_data_new.txt")

#Grabbing both the real images and the theoretical links for a little trick later
#TAKES A LONG TIME TO RUN

#images_real <- c()
#for(i in 1:934){
#page <- read_html(urls[i])
#node <- html_elements(page,"img")
#images_real <- append(images_real, html_attr(node, "src"))
#}

#Saving the data for later
#write_lines(images_real, "image_links.txt")
images_real <- read_lines("image_links.txt")
```

```{r images}
#Creating all theoretical links
images_theory <- c()
for(i in 1:934){
images_theory[i] <- str_c('https://www.aidedd.org/dnd/images/', url_names[i],".jpg")
}

#Creating a tibble with NA's for all the monsters that have no real image to link.
#Will be merged after more data manipulation
image_merger_real <- tibble(image = images_real, merge = images_real)
image_merger_theory <- tibble(name=names, merge = images_theory)
images_merged <- left_join(image_merger_theory, image_merger_real, by = "merge")
images_merged <- select(images_merged, "name", "image")


#Removing empty values and widening the monster dataframe
slim_monster_data_new <- monster_data_new[!monster_data_new == ""]
monster_array_new <- tibble(name=slim_monster_data_new[1:912*4-3], type=slim_monster_data_new[1:912*4-2], desc=slim_monster_data_new[1:912*4-1], source=slim_monster_data_new[1:912*4])

#splitting various variables into their own collumns
monster_array2 <- separate(monster_array_new, type, into=c("size_type", "subrace_alignment","excess1","excess2"), sep="\\(")
monster_array3 <- separate(monster_array2, col = subrace_alignment, into=c("subrace", "alignment"), sep="\\), ")
monster_array4 <- separate(monster_array3, col = size_type, into=c("size_type", "alignment"), sep=", ")
monster_array4$alignment[is.na(monster_array4$alignment)] <- monster_array3$alignment[!is.na(monster_array3$alignment)]
monster_array5 <- separate(monster_array4, col = size_type, into=c("size", "type"), sep=" ")

#corrections to two fickle data points
monster_array5$alignment[170] <- 'neutral good (50 %) or neutral evil (50 %)'
monster_array5$subrace[170] <- NA
monster_array5$alignment[296] <- "chaotic good (75 %) or neutral evil (25 %)"

#removing excess columns
monster_array6 <- select(monster_array5, -excess1, -excess2)

#merging image links
monster_array6 <- left_join(monster_array6, images_merged, by="name")
```

## Cleaning the Data

The data scraped from the web was quite messy. There are about 100 lines of code dedicated to cleaning it, so this report will summarize the most notable challenges and steps taken to overcome them.

Most notably, one variable, "desc" contained information of the form: "var1 value1 var2 value2 var3 value3...". The trouble I faced with extracting this data was that not every variable of interest was in every entry. My solution was to loop through the key variables I wanted to extract, separating the desc variable into two columns, the first labeled after the key variable, and the second lebeled "desc", and containing all the remaining information. At the end of this loop, the data are not in the correct columns, but are instead shifted an indefinite number of columns to the right. Luckily, standing between the values and their correct positions are NA values, which can be "surfed" by checking each column right to left, to see if the column to its left is an NA value, and if so, shifting the value one column to the left. This process shifts the values to their correct columns. A similar method was used to separate the different types of speeds, such as flying, swimming, and climbing.

Another notable issue was the parsing of the Challenge Rating, or CR of the monsters. Parsing the fractions was returning inaccurate values, so I manually replaced the three possible fractions, 1/2, 1/4, and 1/8 with their decimal equivalents, and then parsed every other number. Many other variables were separated with stringr and then parsed as numbers.

The last significant challenge was creating Boolean columns to select monsters by their damage resistances, vulnerabilities, and immunities, as well as by the languages they speak, the senses they use, and the conditions they are immune to.

Besides these large challenges, many monsters have small caveats to the typical rules, which act somewhat like a baked potato in a car's gas tank, breaking my original for loop, as well as some of the stringr patterns. Most of these were easy to locate, however, and the next largest issues were solvable with a line or two of code.

```{r classy cleaning}
#Loop that takes a character vector of stats, and separates the desc variable into many variables of those stats.
#I've never killed a man, but God help anyone who touches this code. This took over 8 hours. Don't fuck it up.

#iteratively splitting descriptive text by notable stats, and pushing everything important to the right
monster_array_it <- monster_array6
stats <- c("Armor Class ", "Hit Points ", "Speed ", "STR","DEX","CON","INT","WIS","CHA","Saving Throws ", "Skills ", "Damage Vulnerabilities ", "Damage Resistances ", "Damage Immunities ", "Condition Immunities ", "Senses ", "Languages ", "Challenge ", "Proficiency Bonus ") 
n <- length(stats)
for(i in 2:n){
  monster_array_it <- separate(monster_array_it, desc, into=c(stats[i-1],'desc'), sep=stats[i], fill='left')
}
#pushing everything that needs to be pushed back to the left by "surfing the NAs"
nn <- which(colnames(monster_array_it)=="desc")
n <- nn-length(stats)+1
for(i in nn:n){
  shift <- is.na(monster_array_it[i])
  monster_array_it[shift,i] <- monster_array_it[shift,i+1]
  monster_array_it[shift,i+1] <- NA
}

#Splitting speeds by the same method
stats <- c("speed", "burrow","climb","fly","swim")
nn <- length(stats)
for(i in 2:nn){
  monster_array_it <- separate(monster_array_it, `Speed `, into=c(stats[i-1],'Speed '), sep=stats[i], fill='left')
}
nn <- which(colnames(monster_array_it)=="Speed ")
n <- nn-length(stats)+1
for(i in nn:n){
  shift <- is.na(monster_array_it[i])
  monster_array_it[shift,i] <- monster_array_it[shift,i+1]
  monster_array_it[shift,i+1] <- NA
}
monster_array_it$speed <- parse_number(monster_array_it$speed)

#corrections
monster_array_it$CHA[799] <- "12 (+1)"
monster_array_it$CHA[716] <- "3 (-4)"
monster_array_it$`Damage Resistances `[799] <- "bludgeoning, piercing"
monster_array_it$`Senses `[716] <- "blindsight 10 ft., darkvision 60 ft., passive Perception 10"
monster_array_it$source[82] <- "TashaÂ´s Cauldron of Everything"
monster_array_it <- monster_array_it[!str_detect(monster_array_it$source, 'Rules'),]

#Cutting Out Modifiers
stats <- c("STR","DEX","CON","INT","WIS","CHA")
for(stat in stats){
  monster_array_it <- separate(monster_array_it, stat, into = c(stat, str_c(stat, " Modifier")), sep = " ", convert = TRUE)
}

#Fun little corrections
monster_array_it <- monster_array_it[!str_equal(monster_array_it$name, 'Drake Companion'),]
monster_array_it <- monster_array_it[rowSums(is.na(monster_array_it)) != ncol(monster_array_it), ]

#Splitting AC and Armor
monster_array_it$`Armor Class ` <- str_remove(monster_array_it$`Armor Class `, "Armor Class ")
monster_array_it <- separate_wider_delim(data = monster_array_it, cols = `Armor Class `, delim = " ",names = c("AC", "Armor"), too_many = 'merge', too_few = 'align_start')
monster_array_it$AC <- parse_number(monster_array_it$AC)

#Splitting CR and XP
monster_array_it <- separate_wider_delim(data = monster_array_it, cols = `Challenge `, delim = " ",names = c("CR", "XP"), too_many = 'merge', too_few = 'align_start')
monster_array_it$CR[str_detect(monster_array_it$CR, "1/2")] <- 0.5
monster_array_it$CR[str_detect(monster_array_it$CR, "1/4")] <- 0.25
monster_array_it$CR[str_detect(monster_array_it$CR, "1/8")] <- 0.125
monster_array_it$CR <- parse_number(monster_array_it$CR)

#Splitting HP and HP_rolled
monster_array_it <- separate_wider_delim(data = monster_array_it, cols = `Hit Points `, delim = " ",names = c("HP", "HP_rolled"), too_many = 'merge', too_few = 'align_start')
monster_array_it$HP <- parse_number(monster_array_it$HP)

#Cleaning alignment
monster_array_it$alignment <- str_remove(monster_array_it$alignment, "typically ")
monster_array_it$alignment <- str_to_title(monster_array_it$alignment)
monster_array_it$simple_alignment <- NA
alignments <- c("Evil", "Good", "Neutral", "Any")
for (str in alignments) {
  monster_array_it$simple_alignment[str_detect(monster_array_it$alignment, str)] <- str
}
monster_array_it$simple_alignment[is.na(monster_array_it$simple_alignment)] <- "Unaligned"

#Capitalizing
monster_array_it$type <- str_to_title(monster_array_it$type)

#Splitting res/imm into nonmagical and typical
monster_array_it <- separate(monster_array_it, "Damage Resistances ", into=c("Damage Resistances", "Nonmagical Resistances"), sep=";")
slide <- str_detect(monster_array_it$`Damage Resistances`, "nonmagical")
slide[is.na(slide)] <- FALSE
monster_array_it$`Nonmagical Resistances`[slide] <- monster_array_it$`Damage Resistances`[slide]
monster_array_it$`Damage Resistances`[slide] <- NA
monster_array_it <- separate(monster_array_it, "Damage Immunities ", into=c("Damage Immunities", "Nonmagical Immunities"), sep=";")
slide <- str_detect(monster_array_it$`Damage Immunities`, "nonmagical")
slide[is.na(slide)] <- FALSE
monster_array_it$`Nonmagical Immunities`[slide] <- monster_array_it$`Damage Immunities`[slide]
monster_array_it$`Damage Immunities`[slide] <- NA

#Creating boolean columns for specific resistances
damages <- c("acid","bludgeoning","cold","fire","force","lightning","necrotic","piercing","poison","psychic","radiant","slashing","thunder")
for (dmg in damages) {
  monster_array_it <- cbind(monster_array_it, str_detect(monster_array_it$`Damage Resistances`, pattern=dmg))
  colnames(monster_array_it)[length(colnames(monster_array_it))] <- paste0(dmg, "_res")
  monster_array_it[is.na(monster_array_it[length(colnames(monster_array_it))]),length(colnames(monster_array_it))] <- FALSE
}

#Creating boolean columns for specific immunities
for (dmg in damages) {
  monster_array_it <- cbind(monster_array_it, str_detect(monster_array_it$`Damage Immunities`, pattern=dmg))
  colnames(monster_array_it)[length(colnames(monster_array_it))] <- paste0(dmg, "_imm")
  monster_array_it[is.na(monster_array_it[length(colnames(monster_array_it))]),length(colnames(monster_array_it))] <- FALSE
}

#Creating boolean columns for specific languages
languages <- c("Common", "Dwarvish","Elvish","Giant","Gnomish","Goblin","Halfling","Orc","Abyssal","Celestial","Draconic","Deep Speech","Infernal","Primordial","Aquan","Auran","Ignan","Terran","Sylvan","Undercommon")
for (lng in languages) {
  monster_array_it <- cbind(monster_array_it, str_detect(monster_array_it$`Languages `, pattern=lng))
  colnames(monster_array_it)[length(colnames(monster_array_it))] <- lng
  monster_array_it[is.na(monster_array_it[length(colnames(monster_array_it))]),length(colnames(monster_array_it))] <- FALSE
}

#monster_array_it$`Nonmagical Resistance` <- str_detect(monster_array_it$`Damage Resistances `, "nonmagical")
#monster_array_it$`Damage Resistances ` <- str_split(monster_array_it$`Damage Resistances `, ", |; ")
#monster_array_it$`Nonmagical Immunity` <- str_detect(monster_array_it$`Damage Immunities `, "nonmagical")
#monster_array_it$`Damage Immunities ` <- str_split(monster_array_it$`Damage Immunities `, ", |; ")
#monster_array_it$`Nonmagical Immunity`[is.na(monster_array_it$`Nonmagical Immunity`)] <- FALSE
#monster_array_it$`Nonmagical Resistance`[is.na(monster_array_it$`Nonmagical Resistance`)] <- FALSE

#storing the final dataframe
monsters <- unique(monster_array_it)

#Sick ass stats and picture
#kbl(monsters) %>%
  #kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
#knitr::include_graphics(monsters$image[108])

#More sick ass stats and another picture
#kbl(monsters[117,]) %>%
  #kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
#knitr::include_graphics(monsters$image[117])

#knitr::include_graphics(monsters$image[160])

#pictured <- monsters[!is.na(monsters$image),]
#pictured[pictured$CR < 1,]

#knitr::include_graphics(pictured$image[pictured$CR < 1,])
```

```{r gratifying graphs}
#UNIVARIATES
ggplot(monsters) + geom_histogram(aes(CR), binwidth = 1, col = 'red', fill='red', alpha = .6) + theme_light()
ggplot(monsters) + geom_histogram(aes(AC), binwidth = 1, col = 'red', fill='red', alpha = .6) + theme_light()
ggplot(monsters) + geom_density(aes(INT), binwidth = 1, col = 'red', fill='red', alpha = .6) + theme_light() + facet_wrap(~fire_imm)
ggplot(monsters) + geom_boxplot(aes(x=INT, y=fire_imm, fill=fire_imm), alpha = .6) + theme_light()

#Comparing core stats by size
ggplot(monsters) + geom_density(aes(DEX), col = 'red', fill='red', alpha = .3) + geom_density(aes(STR, y=-..density..), col = 'blue', fill='blue', alpha = .3) + theme_light() + facet_wrap(~fire_imm)


#Faceting relationships by core stat
facet_by <- stats
faceting <- pivot_longer(monsters, cols = facet_by, names_to = "facet_by")
ggplot(faceting) + geom_histogram(aes(x=value), fill='red', binwidth = 1, alpha = .6) + facet_wrap(~facet_by) + theme_light()
ggplot(faceting) + geom_histogram(aes(x=value, fill=size), binwidth = 1, alpha = .6) + facet_wrap(~facet_by) + theme_light()

#Core by Size
ggplot(faceting) + geom_boxplot(aes(x=value, y=fct_reorder(size, value, .fun = median), fill=size), show.legend = FALSE) + facet_wrap(~facet_by) + theme_light()
ggplot(faceting) + geom_boxplot(aes(x=value, y=fct_reorder(simple_alignment, value, .fun = median), fill=simple_alignment), show.legend = FALSE) + facet_wrap(~facet_by) + theme_light()
ggplot(faceting) + geom_boxplot(aes(x=value, y=Abyssal, fill=Abyssal), show.legend = FALSE) + facet_wrap(~facet_by) + theme_light()

#CR and Core
ggplot(faceting) + geom_point(aes(x=CR, y=value), alpha=.1) + facet_wrap(~facet_by) + theme_light()
ggplot(faceting) + geom_density_2d(aes(x=CR, y=value)) + facet_wrap(~facet_by) + theme_light()
#HP and Core
ggplot(faceting) + geom_point(aes(x=HP, y=value), alpha = .1) + facet_wrap(~facet_by) + theme_light()
ggplot(faceting) + geom_density_2d(aes(x=HP, y=value)) + facet_wrap(~facet_by) + theme_light()
#AC and Core
ggplot(faceting) + geom_point(aes(x=AC, y=value), alpha = .1) + facet_wrap(~facet_by) + theme_light()
ggplot(faceting) + geom_density_2d(aes(x=AC, y=value)) + facet_wrap(~facet_by) + theme_light()

#The six stats and the relationships to others
faceting$stat <- rep(monsters$STR, each=6)
ggplot(faceting) + geom_point(aes(x=value, y=stat), alpha=.1) + facet_wrap(~facet_by) + theme_light()
faceting$stat <- rep(monsters$DEX, each=6)
ggplot(faceting) + geom_point(aes(x=value, y=stat), alpha=.1) + facet_wrap(~facet_by) + theme_light()
faceting$stat <- rep(monsters$CON, each=6)
ggplot(faceting) + geom_point(aes(x=value, y=stat), alpha=.1) + facet_wrap(~facet_by) + theme_light()
faceting$stat <- rep(monsters$INT, each=6)
ggplot(faceting) + geom_point(aes(x=value, y=stat), alpha=.1) + facet_wrap(~facet_by) + theme_light()
faceting$stat <- rep(monsters$WIS, each=6)
ggplot(faceting) + geom_point(aes(x=value, y=stat), alpha=.1) + facet_wrap(~facet_by) + theme_light()
faceting$stat <- rep(monsters$CHA, each=6)
ggplot(faceting) + geom_point(aes(x=value, y=stat), alpha=.1) + facet_wrap(~facet_by) + theme_light()

#FAT GRID
pairs(monsters[,7:12*2+1], pch = 19, col = rgb(0,0,0, alpha=.05), main = "Relationships Between Core Statistics")

ggplot(faceting) + geom_point(aes(x=CR, y=value), alpha=.1) + facet_grid(facet_by~size) + theme_light()

#Strength by Size
ggplot(monsters) + geom_boxplot(aes(x=STR, y=size, fill=fct_reorder(size, STR, .fun = median)), show.legend = FALSE) +theme_light()
#AC by Size
ggplot(monsters) + geom_boxplot(aes(x=AC, y=size, fill=size), show.legend = FALSE) +theme_light()
#HP by Size
ggplot(monsters) + geom_boxplot(aes(x=HP, y=fct_reorder(size, HP, .fun = median), fill=fct_reorder(size, HP, .fun = median)), show.legend = FALSE) +theme_light()
#Cha by type
ggplot(monsters) + geom_boxplot(aes(x=CHA, y=fct_reorder(type, CHA, .fun = median), fill=fct_reorder(type, CHA, .fun = median)), show.legend = FALSE) +theme_light()
#Number of each type
ggplot(monsters) +geom_bar(aes(y=fct_reorder(type, type, .fun = length), fill = simple_alignment)) + theme_light()

ggplot(monsters) +geom_bar(aes(y=fct_reorder(source, source, .fun = length))) + theme_light()
ggplot(monsters) +geom_bar(aes(y=fct_reorder(alignment, alignment, .fun = length))) + theme_light()
#ggplot(monsters) +geom_bar(aes(y=`Nonmagical Immunity`)) + theme_light()
#ggplot(monsters) +geom_bar(aes(y=`Nonmagical Resistance`)) + theme_light()
#AC over CR
ggplot(monsters) + geom_point(aes(y=AC, x=CR), alpha=.1) + geom_density_2d(aes(y=AC, x=CR), alpha = .3) + theme_light()
ggplot(monsters) + geom_point(aes(y=AC, x=CR), alpha=.1) + theme_light()
ggplot(monsters) + geom_density_2d(aes(y=AC, x=CR)) + theme_light()
ggplot(monsters) + geom_density_2d_filled(aes(y=AC, x=CR), show.legend = FALSE) + theme_light()
ggplot(monsters) + geom_point(aes(y=AC, x=CR), alpha=.1) + theme_light() + facet_wrap(~size)
ggplot(monsters) + geom_point(aes(y=AC, x=CR), alpha=.1) + theme_light() + facet_wrap(~simple_alignment)
ggplot(monsters) + geom_point(aes(y=AC, x=CR), alpha=.1) + theme_light() + facet_wrap(~type)
#Alignment by type
ggplot(monsters) + geom_col(aes(y=type, x=1, fill=fct_reorder(simple_alignment, simple_alignment, .fun = length)),position = "fill") + theme_light()

#Core stats by type
ggplot(monsters) + geom_col(aes(x=STR, y=1, fill=fct_reorder(type, STR, .fun = median)), alpha = .6) + theme_light()

#CR distribution by type
ggplot(monsters) + geom_histogram(aes(x=CR), fill='red', binwidth = 1, alpha = .6) + facet_wrap(~type) + theme_light()
stat <- stats[1]

ggplot(monsters) + geom_boxplot(aes(x=STR, y=fct_reorder(type, STR, .fun = median), fill=type), show.legend = FALSE) +theme_light()
ggplot(monsters) + geom_boxplot(aes(x=DEX, y=fct_reorder(type, DEX, .fun = median), fill=type), show.legend = FALSE) +theme_light()
ggplot(monsters) + geom_boxplot(aes(x=CON, y=fct_reorder(type, CON, .fun = median), fill=type), show.legend = FALSE) +theme_light()
ggplot(monsters) + geom_boxplot(aes(x=INT, y=fct_reorder(type, INT, .fun = median), fill=type), show.legend = FALSE) +theme_light()
ggplot(monsters) + geom_boxplot(aes(x=WIS, y=fct_reorder(type, WIS, .fun = median), fill=type), show.legend = FALSE) +theme_light()
ggplot(monsters) + geom_boxplot(aes(x=CHA, y=fct_reorder(type, CHA, .fun = median), fill=type), show.legend = FALSE) +theme_light()

#AC by type
ggplot(monsters) + geom_boxplot(aes(x=AC, y=fct_reorder(type, AC, .fun = median), fill=type), show.legend = FALSE) +theme_light()
```
